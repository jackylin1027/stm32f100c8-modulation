//**********************************************************************************************************************
//
// Copyright (C) 2010, FINE-TEK CO.,LTD. Taiwan  All Rights Reserved
//
//! @file 		 eph_comm_task.c
//
//! @author 	 Jacky Lin
//
//! @date 		 2022/07/26
//
//  @brief 		 Task Subroutine
//
//**********************************************************************************************************************
//**********************************************************************************************************************
//
// I N C L U D E   F I L E S   /   E X T E R N A L   V A R I A B L E S 
//
//**********************************************************************************************************************
#include "..\drv_src\eph_comm_drv.h" 
#include "eph_comm_glb_vars.h"
//**********************************************************************************************************************
//
// C   P L U S   P L U S   C O M P A T I A B L E   D E F I N I T I O N 
//
//**********************************************************************************************************************
#ifdef __cplusplus
extern "C"
{
#endif
  
const UINT8 gb_eph_comm_encrypt_public_key[]={0x1A, 0x2B, 0x3C, 0x4D, 0x5E, 0x6F, 0x00};
//**********************************************************************************************************************
//
// Copyright (C) 2010, FINE-TEK CO.,LTD. Taiwan  All Rights Reserved
//
//! @fn 			 eph_comm_polls_device_judge
//
//! @author 	 Jacky Lin
//
//! @date 		 2022/08/09
//
//! @brief 		 task function
//
//! @param 		 None
//
//! @return 	 None
//
//********************************************************************************************************************** 
void eph_comm_polls_device_judge()
{
    //===== eph comm 加入 封包解析最大數量的判斷機制, Ver0.0.02 =====
    if(++gb_eph_comm_device_ptr >= EPH_COMM_GET_MAX_DEVICE_NUM())
    {       
        //===== 小循環(delay polls)結束後, 將 SCANRATE flag 設定成 inactive, 等待下次 SCANRATE active, Ver0.0.02 ====
        EPH_COMM_SET_SCANRATE_FLAG(PFC_SCANRATE_INACTIVE);
        gb_eph_comm_device_ptr=0;
    } 
}
//**********************************************************************************************************************
//
// Copyright (C) 2010, FINE-TEK CO.,LTD. Taiwan  All Rights Reserved
//
//! @fn 			 eph_comm_rs485_receiving_and_checking
//
//! @author 	 Jacky Lin
//
//! @date 		 2022/08/09
//
//! @brief 		 task function
//
//! @param 		 None
//
//! @return 	 None
//
//********************************************************************************************************************** 
void eph_comm_rs485_receiving_and_checking(UINT8 byte)
{
    if(PFC_OPERATION_MODE_CHK()<PFC_OPERATION_COMREAD)
        return;
    
    gb_eph_comm_rs485_response[gb_eph_comm_rs485_ptr++]=byte;
    EPH_COMM_RS485_RESET_TIMEOUT_TIMER_API(5);   
    switch(gb_eph_comm_rs485_state)
    {
    case EPH_COMM_RS485STA_IDEL:
        if(gb_eph_comm_rs485_response[EPH_COMM_RS485_ADDRESS]==EPH_COMM_RS485_TAG)
            gb_eph_comm_rs485_state=EPH_COMM_RS485STA_IDENT;           
      break;
    case EPH_COMM_RS485STA_IDENT:
        if(gb_eph_comm_rs485_response[EPH_COMM_RS485_DEVICE_NUMBER]==gs_pfc_vars.product_date[11])
            gb_eph_comm_rs485_state=EPH_COMM_RS485STA_IDENT1;
        break;
    case EPH_COMM_RS485STA_IDENT1:
        if(gb_eph_comm_rs485_response[EPH_COMM_RS485_DEVICE_NUMBER+1]==gs_pfc_vars.product_date[10])
            gb_eph_comm_rs485_state=EPH_COMM_RS485STA_IDENT2;
        break;        
    case EPH_COMM_RS485STA_IDENT2:
        if(gb_eph_comm_rs485_response[EPH_COMM_RS485_DEVICE_NUMBER+2]==gs_pfc_vars.product_date[9])
            gb_eph_comm_rs485_state=EPH_COMM_RS485STA_GROUP;
        break;           
    case EPH_COMM_RS485STA_GROUP:    
        if(gb_eph_comm_rs485_response[EPH_COMM_RS485_GROUP_NUMBER]==0x00)
            gb_eph_comm_rs485_state=EPH_COMM_RS485STA_GROUP1;
        break;
    case EPH_COMM_RS485STA_GROUP1:    
        if(gb_eph_comm_rs485_response[EPH_COMM_RS485_GROUP_NUMBER+1]==0xFF)
            gb_eph_comm_rs485_state=EPH_COMM_RS485STA_STATION;
        break;
    case EPH_COMM_RS485STA_STATION:    
        if(gb_eph_comm_rs485_response[EPH_COMM_RS485_STATION]==0x00)
            gb_eph_comm_rs485_state=EPH_COMM_RS485STA_STATION1; 
        break;
    case EPH_COMM_RS485STA_STATION1:    
        if(gb_eph_comm_rs485_response[EPH_COMM_RS485_STATION+1]==0xFF)
            gb_eph_comm_rs485_state=EPH_COMM_RS485STA_FUNC;
        break;
    case EPH_COMM_RS485STA_FUNC:    
        if(gb_eph_comm_rs485_response[EPH_COMM_RS485_FUNC]==0x11)
            gb_eph_comm_rs485_state=EPH_COMM_RS485STA_FUNCREAD;
        else if(gb_eph_comm_rs485_response[EPH_COMM_RS485_FUNC]==0x22)
            gb_eph_comm_rs485_state=EPH_COMM_RS485STA_FUNCMONITOR;         
      break;    
    case EPH_COMM_RS485STA_FUNCREAD:    
        if(gb_eph_comm_rs485_response[EPH_COMM_RS485_FUNC+1]==0xEE)
        {
            gb_eph_comm_rs485_state=EPH_COMM_RS485STA_FUNC_OK;    
            gb_eph_comm_rs485_func=EPH_COMM_RS485STA_FUNCREAD;
        }
        //===== 新增競爭廠商功能 - RS-485讀取模式, Ver 0.0.03 =====
        PFC_EPH_COMM_TRANSMITTER_PROCESS_TIMEOUT(1);
      break;       
    case EPH_COMM_RS485STA_FUNCMONITOR:    
        if(gb_eph_comm_rs485_response[EPH_COMM_RS485_FUNC+1]==0xDD)
        {
            gb_eph_comm_rs485_state=EPH_COMM_RS485STA_FUNC_OK;        
            gb_eph_comm_rs485_func=EPH_COMM_RS485STA_FUNCMONITOR;
        }
      break;         
    }
}
//**********************************************************************************************************************
//
// Copyright (C) 2010, FINE-TEK CO.,LTD. Taiwan  All Rights Reserved
//
//! @fn 			 eph_comm_receive_parsing
//
//! @author 	 Jacky Lin
//
//! @date 		 2022/07/28
//
//! @brief 		 task function
//
//! @param 		 None
//
//! @return 	 None
//
//********************************************************************************************************************** 
UINT16 eph_comm_decrypt_func(UINT8* source_data, UINT16 length)
{
    UINT16 g_decrypt_datalen,i,k;
    UINT8 g_addBuf[EPH_COMM_ENCRYPT_BLOCK],g_xorBuf[EPH_COMM_ENCRYPT_BLOCK],g_exchangeBuf[EPH_COMM_ENCRYPT_BLOCK],g_exdb[2];
    UINT16 byte_count=*(source_data+2)+(*(source_data+3)<<EPH_COMM_BYTE_BITS);
    UINT8 leading_code=*(source_data+4);
    UINT8* tmep_data=(UINT8*)(source_data+5);
    
    g_decrypt_datalen = byte_count - 1 + 2;
    for(i = 0; i < leading_code; i++)
    {
        for (k = 0; k < EPH_COMM_ENCRYPT_BLOCK; k++) 
            g_exchangeBuf[k] = *(tmep_data + i * EPH_COMM_ENCRYPT_BLOCK + k);
        
        if ((i%2) == 0) // odd block.
        {
            // Exchange
            g_xorBuf[0] = g_exchangeBuf[0];
            g_exdb[0] = (UINT8)((g_exchangeBuf[1] >> 4) & 0x0F);
            g_exdb[1] = (UINT8)(g_exchangeBuf[1] & 0x0F);
            g_xorBuf[1] = (UINT8)((g_exdb[1] << 4) + g_exdb[0]);
            g_xorBuf[2] = g_exchangeBuf[2];
            g_exdb[0] = (UINT8)((g_exchangeBuf[3] >> 4) & 0x0F);
            g_exdb[1] = (UINT8)(g_exchangeBuf[3] & 0x0F);
            g_xorBuf[3] = (UINT8)((g_exdb[1] << 4) + g_exdb[0]);
            g_xorBuf[4] = g_exchangeBuf[4];
            g_exdb[0] = (UINT8)((g_exchangeBuf[5] >> 4) & 0x0F);
            g_exdb[1] = (UINT8)(g_exchangeBuf[5] & 0x0F);
            g_xorBuf[5] = (UINT8)((g_exdb[1] << 4) + g_exdb[0]);
            g_xorBuf[6] = g_exchangeBuf[6];
            // Add
            g_addBuf[1] = g_xorBuf[1];
            g_addBuf[2] = (UINT8)(g_xorBuf[1] ^ g_xorBuf[2]);
            g_addBuf[3] = (UINT8)(g_xorBuf[2] ^ g_xorBuf[3]);
            g_addBuf[4] = (UINT8)(g_xorBuf[3] ^ g_xorBuf[4]);
            g_addBuf[5] = (UINT8)(g_xorBuf[4] ^ g_xorBuf[5]);
            g_addBuf[6] = (UINT8)(g_xorBuf[5] ^ g_xorBuf[6]);
            g_addBuf[0] = (UINT8)(g_xorBuf[6] ^ g_xorBuf[0]);
            
            if(i==0)
            {
                memcpy(gb_eph_comm_encrypt_fix_key,gb_eph_comm_encrypt_public_key,EPH_COMM_ENCRYPT_BLOCK);// Load initial fix key.               
                for (k = 0; k < EPH_COMM_ENCRYPT_BLOCK; k++) { *(source_data + i * EPH_COMM_ENCRYPT_BLOCK + k + 2) = (UINT8)(g_addBuf[k] - gb_eph_comm_encrypt_fix_key[k]); }
            }       
            else
            {
                for (k = 0; k < EPH_COMM_ENCRYPT_BLOCK; k++) { *(source_data + i * EPH_COMM_ENCRYPT_BLOCK + k + 2) = (UINT8)(g_addBuf[k] - gb_eph_comm_encrypt_fix_key[k]); }                        
            }  
            for (k = 0; k < EPH_COMM_ENCRYPT_BLOCK; k++) { gb_eph_comm_encrypt_fix_key[k] = g_xorBuf[k]; } // Upadte random key.
        }
        else // even block
        {
            // Exchange
            g_exdb[0] = (UINT8)((g_exchangeBuf[0] >> 4) & 0x0F);
            g_exdb[1] = (UINT8)(g_exchangeBuf[0] & 0x0F);
            g_xorBuf[0] = (UINT8)((g_exdb[1] << 4) + g_exdb[0]);
            g_xorBuf[1] = g_exchangeBuf[1];
            g_exdb[0] = (UINT8)((g_exchangeBuf[2] >> 4) & 0x0F);
            g_exdb[1] = (UINT8)(g_exchangeBuf[2] & 0x0F);
            g_xorBuf[2] = (UINT8)((g_exdb[1] << 4) + g_exdb[0]);
            g_xorBuf[3] = g_exchangeBuf[3];
            g_exdb[0] = (UINT8)((g_exchangeBuf[4] >> 4) & 0x0F);
            g_exdb[1] = (UINT8)(g_exchangeBuf[4] & 0x0F);
            g_xorBuf[4] = (UINT8)((g_exdb[1] << 4) + g_exdb[0]);
            g_xorBuf[5] = g_exchangeBuf[5];
            g_exdb[0] = (UINT8)((g_exchangeBuf[6] >> 4) & 0x0F);
            g_exdb[1] = (UINT8)(g_exchangeBuf[6] & 0x0F);
            g_xorBuf[6] = (UINT8)((g_exdb[1] << 4) + g_exdb[0]);
            // Add
            g_addBuf[0] = g_xorBuf[0];
            g_addBuf[1] = (UINT8)(g_xorBuf[0] ^ g_xorBuf[1]);
            g_addBuf[2] = (UINT8)(g_xorBuf[1] ^ g_xorBuf[2]);
            g_addBuf[3] = (UINT8)(g_xorBuf[2] ^ g_xorBuf[3]);
            g_addBuf[4] = (UINT8)(g_xorBuf[3] ^ g_xorBuf[4]);
            g_addBuf[5] = (UINT8)(g_xorBuf[4] ^ g_xorBuf[5]);
            g_addBuf[6] = (UINT8)(g_xorBuf[5] ^ g_xorBuf[6]);
        
            for (k = 0; k < EPH_COMM_ENCRYPT_BLOCK; k++) 
            { 
                *(source_data + i * EPH_COMM_ENCRYPT_BLOCK + k + 2) = (UINT8)(g_addBuf[k] - gb_eph_comm_encrypt_fix_key[k]); 
            }
            for (k = 0; k < EPH_COMM_ENCRYPT_BLOCK; k++) 
            { 
                gb_eph_comm_encrypt_fix_key[k] = g_xorBuf[k]; 
            }
            // Upadte random key.
        }            
    }
    return g_decrypt_datalen;
}
//**********************************************************************************************************************
//
// Copyright (C) 2010, FINE-TEK CO.,LTD. Taiwan  All Rights Reserved
//
//! @fn 			 eph_comm_rs485_recv_parse
//
//! @author 	 Jacky Lin
//
//! @date 		 2022/08/08
//
//! @brief 		 task function
//
//! @param 		 None
//
//! @return 	 None
//
//********************************************************************************************************************** 
void eph_comm_rs485_recv_parse()
{
    UINT8 i;
    UINT16 chksum=0;
    UINT16 response_format;
    
    eph_comm_decrypt_func((UINT8*)&EPH_COMM_BUFFER[0], EPH_COMM_REVC_COUNT);
    STC_EPH_COMM_RECEIVE_INFO_PACKAGE* recv = (STC_EPH_COMM_RECEIVE_INFO_PACKAGE*)&EPH_COMM_BUFFER[EPH_COMM_DECRYPT_DATA_START_BYTE];
    //==================== STC_EPH_COMM_RS485_HEADER ==================
    gs_eph_comm_rHeader.StartTag=EPH_COMM_RS485_TAG;
    
    //===== 競爭廠商功能 - RS-485讀取模式&監控模式回復封包判斷, Ver 0.0.03 =====
    if(PFC_OPERATION_MODE==PFC_OPERATION_COMREADINST)
    {
        if(gb_eph_comm_rs485_func==EPH_COMM_RS485STA_FUNCREAD)
        {
            memcpy(gs_eph_comm_rHeader.thisCommMode, "T4", sizeof(gs_eph_comm_rHeader.thisCommMode));
            response_format=0;
        }
        else if(gb_eph_comm_rs485_func==EPH_COMM_RS485STA_FUNCMONITOR)
        {
            memcpy(gs_eph_comm_rHeader.thisCommMode, "T5", sizeof(gs_eph_comm_rHeader.thisCommMode));
            response_format=1;
        }
    }
    else
    {
        if(!(PFC_OPERATION_MODE%2))
        {
          memcpy(gs_eph_comm_rHeader.thisCommMode, "T4", sizeof(gs_eph_comm_rHeader.thisCommMode));
          response_format=0;
        }
        else
        {
          memcpy(gs_eph_comm_rHeader.thisCommMode, "T5", sizeof(gs_eph_comm_rHeader.thisCommMode)); 
          response_format=1;
        }
    }
    
    gs_eph_comm_rHeader.DeviceType='B';
    
    gs_eph_comm_rHeader.UserNumberTag='W';
    fn_hex2asciiString_inverse(gs_eph_comm_rHeader.UserNumber,recv->meter_id,sizeof(recv->meter_id), 1);
    memcpy(gs_eph_comm_rHeader.UserNumber, recv->meter_id, sizeof(recv->meter_id));
    //==================== STC_EPH_COMM_RS485_HEADER ==================
    
    //==================== STC_EPH_COMM_RS485_METERID ==================
    gs_eph_comm_rMeterID.MeterIDTag='M';
    memcpy(gs_eph_comm_rMeterID.MeterID, recv->meter_id, sizeof(recv->meter_id));
    //==================== STC_EPH_COMM_RS485_METERID ==================
    
    //==================== STC_EPH_COMM_RS485_VOLUME ==================
    gs_eph_comm_rVolume.VolumeExponentialTag='V';
    fn_intValue2String(gs_eph_comm_rVolume.VolumeExponential,recv->volume,sizeof(gs_eph_comm_rVolume.VolumeExponential));
    gs_eph_comm_rVolume.VolumeExponential[9]='e';
    gs_eph_comm_rVolume.VolumeExponential[10]='-';
    gs_eph_comm_rVolume.VolumeExponential[11]=(recv->caliber==EPH_COMM_DEVICE_DN40) ? EPH_COMM_DEVICE_DN40_DOT_POS : EPH_COMM_DEVICE_NOT_DN40_DOT_POS;  
    //==================== STC_EPH_COMM_RS485_VOLUME ==================
    
    
    //==================== STC_EPH_COMM_RS485_EVENT ==================
    gs_eph_comm_rEvent.lDayTag='L';
    fn_intValue2Number(gs_eph_comm_rEvent.lDay,fn_bcd2decString(recv->l_day),sizeof(gs_eph_comm_rEvent.lDay));   
    gs_eph_comm_rEvent.nDayTag='N';
    fn_intValue2Number(gs_eph_comm_rEvent.nDay,fn_bcd2decString(recv->n_day),sizeof(gs_eph_comm_rEvent.nDay));
    gs_eph_comm_rEvent.oDayTag='O';
    fn_intValue2Number(gs_eph_comm_rEvent.oDay,fn_bcd2decString(recv->o_day),sizeof(gs_eph_comm_rEvent.oDay));
    gs_eph_comm_rEvent.uDayTag='U';
    fn_intValue2Number(gs_eph_comm_rEvent.uDay,fn_bcd2decString(recv->u_day),sizeof(gs_eph_comm_rEvent.uDay));
    gs_eph_comm_rEvent.hDayTag='H';
    fn_intValue2Number(gs_eph_comm_rEvent.hDay,fn_bcd2decString(recv->h_day),sizeof(gs_eph_comm_rEvent.hDay));
    gs_eph_comm_rEvent.bDayTag='B';
    fn_intValue2Number(gs_eph_comm_rEvent.bDay,fn_bcd2decString(recv->b_day),sizeof(gs_eph_comm_rEvent.bDay));    
    gs_eph_comm_rEvent.statusTag='F';
    fn_intValue2Number(gs_eph_comm_rEvent.status,fn_bcd2decString(0x0001),sizeof(gs_eph_comm_rEvent.status));  
    gs_eph_comm_rEvent.userCountTag='C';
    fn_intValue2Number(gs_eph_comm_rEvent.userCount,fn_bcd2decString(recv->user_count),sizeof(gs_eph_comm_rEvent.userCount)); 
    //==================== STC_EPH_COMM_RS485_EVENT ==================
    
    //==================== STC_EPH_COMM_RS485_ERRORCODE ==================
    gs_eph_comm_rErrCode.errorCodeTag='E';
    fn_intValue2Number(gs_eph_comm_rErrCode.errorCode,fn_bcd2decString(0x01),sizeof(gs_eph_comm_rErrCode.errorCode)); 
    //==================== STC_EPH_COMM_RS485_ERRORCODE ==================
    
    
    //==================== STC_EPH_COMM_RS485_TAIL ==================
    gs_eph_comm_rTail.reserveTag='X';
    fn_intValue2Number(gs_eph_comm_rTail.reserve,fn_bcd2decString(0x00),sizeof(gs_eph_comm_rTail.reserve));       
    gs_eph_comm_rTail.CheckSumTag='S';
    fn_intValue2Number(gs_eph_comm_rTail.CheckSum,fn_bcd2decString(0x00),sizeof(gs_eph_comm_rTail.CheckSum)); 
    gs_eph_comm_rTail.EndTag='#';
    //==================== STC_EPH_COMM_RS485_TAIL ==================
    
    UINT8 response_length=0;
    //===== 競爭廠商功能 - RS-485讀取模式&監控模式回復封包判斷, Ver 0.0.03 =====  
    if(response_format==0)
    {
        memcpy((UINT8*)&gb_eph_comm_rs485_response[0],(UINT8*)&gs_eph_comm_rHeader.StartTag,sizeof(gs_eph_comm_rHeader));
        response_length+=sizeof(gs_eph_comm_rHeader);
        memcpy((UINT8*)&gb_eph_comm_rs485_response[response_length],(UINT8*)&gs_eph_comm_rMeterID.MeterIDTag,sizeof(gs_eph_comm_rMeterID));
        response_length+=sizeof(gs_eph_comm_rMeterID);
        memcpy((UINT8*)&gb_eph_comm_rs485_response[response_length],(UINT8*)&gs_eph_comm_rVolume.VolumeExponentialTag,sizeof(gs_eph_comm_rVolume));
        response_length+=sizeof(gs_eph_comm_rVolume);
        memcpy((UINT8*)&gb_eph_comm_rs485_response[response_length],(UINT8*)&gs_eph_comm_rEvent.lDayTag,sizeof(gs_eph_comm_rEvent));
        response_length+=sizeof(gs_eph_comm_rEvent);
        memcpy((UINT8*)&gb_eph_comm_rs485_response[response_length],(UINT8*)&gs_eph_comm_rTail.reserveTag,sizeof(gs_eph_comm_rTail));
        response_length+=sizeof(gs_eph_comm_rTail);
    }
    else if(response_format==1)
    {
        memcpy((UINT8*)&gb_eph_comm_rs485_response[0],(UINT8*)&gs_eph_comm_rHeader.StartTag,sizeof(gs_eph_comm_rHeader));
        response_length+=sizeof(gs_eph_comm_rHeader);
        memcpy((UINT8*)&gb_eph_comm_rs485_response[response_length],(UINT8*)&gs_eph_comm_rMeterID.MeterIDTag,sizeof(gs_eph_comm_rMeterID));
        response_length+=sizeof(gs_eph_comm_rMeterID);
        memcpy((UINT8*)&gb_eph_comm_rs485_response[response_length],(UINT8*)&gs_eph_comm_rVolume.VolumeExponentialTag,sizeof(gs_eph_comm_rVolume));
        response_length+=sizeof(gs_eph_comm_rVolume);     
        memcpy((UINT8*)&gb_eph_comm_rs485_response[response_length],(UINT8*)&gs_eph_comm_rTail.reserveTag,sizeof(gs_eph_comm_rTail));
        response_length+=sizeof(gs_eph_comm_rTail);
    }
    //===== 從＊以後開始加總至＃，不含Check Sum 跟＊、＃ ======//   
    for( i=1;i<response_length-1;i++)
        chksum+=gb_eph_comm_rs485_response[i];    
    chksum=~chksum;
    gb_eph_comm_rs485_response[response_length-3]=chksum&EPH_COMM_LOW_BYTE_MASK;
    gb_eph_comm_rs485_response[response_length-2]=(chksum&EPH_COMM_HIGH_BYTE_MASK)>>EPH_COMM_BYTE_BITS;
       
    EPH_COMM_SLAVE_SET_WRITE_OUT_API();
    for (i=0;i<response_length;i++)
        EPH_COMM_SLAVE_SEND_OUT_API(gb_eph_comm_rs485_response[i]);
    EPH_COMM_SLAVE_SET_READ_IN_API();    
}
//**********************************************************************************************************************
//
// Copyright (C) 2010, FINE-TEK CO.,LTD. Taiwan  All Rights Reserved
//
//! @fn 			 eph_comm_receive_parsing
//
//! @author 	 Jacky Lin
//
//! @date 		 2022/07/28
//
//! @brief 		 task function
//
//! @param 		 None
//
//! @return 	 None
//
//********************************************************************************************************************** 
void eph_comm_receive_parsing()
{
    UINT8 dotPosition=0x00;
    UINT8 recv_id=gb_eph_comm_device_tlb[gb_eph_comm_device_ptr];
    eph_comm_decrypt_func((UINT8*)&EPH_COMM_BUFFER[0], EPH_COMM_REVC_COUNT);
    STC_EPH_COMM_RECEIVE_INFO_PACKAGE* recv = (STC_EPH_COMM_RECEIVE_INFO_PACKAGE*)&EPH_COMM_BUFFER[EPH_COMM_DECRYPT_DATA_START_BYTE];
    STC_EPH_COMM_TRANSMITTER_PACKAGE* transmitter=(STC_EPH_COMM_TRANSMITTER_PACKAGE*)&gs_eph_comm_transmitter[recv_id-1];
    
    //===== MSP430FR2476 要對FRAM操作必須先打開 write protect =====
    FK_DISABLE_FRAM_WRITE_PROTECT();      
    /*      目前 transmitter 未使用                          */
    transmitter->timestamp=(UINT32)recv->timestamp;
    /*      0x1020	4129	0~9/A~F	水號1~4	        用戶水號
            0x1021	4130	0~9/A~F	水號5~8	
            0x1022	4131	0~9/A~F	水號9~12	
            0x1023	4132	0~9/A~F	水號13~16	
            0x1024	4133	0~9/A~F	水號17~20	
            0x1025	4134	0~9/A~F	水號21~24	*/
    FN_MEMCPY_INVERSE_API((UINT8*)&transmitter->userNumber, recv->meter_id, sizeof(recv->meter_id));
    /*      0x1026	4135	0~9/A~F	器號1~4	        水量計器號
            0x1027	4136	0~9/A~F	器號5~8	
            0x1028	4137	0~9/A~F	器號9~12	
            0x1029	4138	0~9/A~F	器號13~16	
            0x102A	4139	0~9/A~F	器號17~20	
            0x102B	4140	0~9/A~F	器號21~24	*/  
    FN_MEMCPY_INVERSE_API((UINT8*)&transmitter->meterID, recv->meter_id, sizeof(recv->meter_id));   
    /*      0x102C	4141	0000~9999	Ver 1030	版本      */
    transmitter->firmwareVersionBCD=(UINT16)recv->firmware_version;
    /*      0x102D	4142	0000~9999	"高位: 口徑
                                                低位: 電池電壓"	        */
    transmitter->caliberWmpowerBCD=((recv->caliber)<<EPH_COMM_BYTE_BITS)|recv->wm_power;
    //===== 依照水表口徑決定小數點的位數, Ver0.0.01 =====
    dotPosition=(recv->caliber==EPH_COMM_DEVICE_DN40) ? EPH_COMM_DEVICE_DN40_DOT_POS : EPH_COMM_DEVICE_NOT_DN40_DOT_POS;       
    /*      0x102E	4143	0000~0099	總積算值10~9	總積算值
            0x102F	4144	0000~9999	總積算值8~5	
            0x1030	4145	0000~9999	總積算值4~1	
            0x1031	4146	0002~0004	小數點位數	                */  
    FN_HEX2BCD_U64_API(recv->volume, (UINT8*)&transmitter->volumeBCD_dotBCD, sizeof(transmitter->volumeBCD_dotBCD));   
    transmitter->volumeBCD_dotBCD=(transmitter->volumeBCD_dotBCD<<EPH_COMM_WORD_BITS)|dotPosition;
    /*      0x1032	4147	0000~0099	瞬間值6~5	瞬間值
            0x1033	4148	0000~9999	瞬間值4~1	
            0x1034	4149	0002~0004	小數點位數	                */
    //===== 瞬間值的小數點固定為5位, Ver0.0.01 =====
    FN_HEX2BCD_U64_API(recv->flow_rate, (UINT8*)&transmitter->flowRateBCD_dotBCD, sizeof(transmitter->flowRateBCD_dotBCD));   
    transmitter->flowRateBCD_dotBCD=(transmitter->flowRateBCD_dotBCD<<EPH_COMM_WORD_BITS)|(0x05); 
    /*      0x1035	4150	0000~0099	正積算值10~9	正積算值
            0x1036	4151	0000~9999	正積算值8~5	
            0x1037	4152	0000~9999	正積算值4~1	
            0x1038	4153	0002~0004	小數點位數	                */  
    //===== 正積算值計算使用讀取回來的 總積算值 - 反積算值, 如果為負數就等於 0x00, Ver0.0.01 =====   
    FN_HEX2BCD_U64_API(recv->plus_total_flow, (UINT8*)&transmitter->plusTotalFlowBCD_dotBCD, sizeof(transmitter->plusTotalFlowBCD_dotBCD));
    transmitter->plusTotalFlowBCD_dotBCD=(transmitter->plusTotalFlowBCD_dotBCD<<EPH_COMM_WORD_BITS)|dotPosition;
    /*      0x1039	4154	0000~0099	反積算值10~9	反積算值
            0x103A	4155	0000~9999	反積算值8~5	
            0x103B	4156	0000~9999	反積算值4~1	
            0x103C	4157	0002~0004	小數點位數	        */
    FN_HEX2BCD_U64_API(recv->reverse_totalizer, (UINT8*)&transmitter->minusTotalFlowBCD_dotBCD, sizeof(transmitter->minusTotalFlowBCD_dotBCD));   
    transmitter->minusTotalFlowBCD_dotBCD=(transmitter->minusTotalFlowBCD_dotBCD<<EPH_COMM_WORD_BITS)|dotPosition;

    transmitter->lDayBCD=(UINT16)recv->l_day;
    transmitter->nDayBCD=(UINT16)recv->n_day;
    transmitter->oDayBCD=(UINT16)recv->o_day;
    transmitter->uDayBCD=(UINT16)recv->u_day;
    transmitter->hDayBCD=(UINT16)recv->h_day;
    transmitter->bDayBCD=(UINT16)recv->b_day;
    transmitter->userCountBCD=(UINT16)recv->user_count;
    transmitter->statusBCD=0x0001;   
    transmitter->lDayBCD_nDayBCD=((UINT16)recv->l_day<<EPH_COMM_BYTE_BITS)|recv->n_day;
    transmitter->oDayBCD_uDayBCD=((UINT16)recv->o_day<<EPH_COMM_BYTE_BITS)|recv->u_day;
    transmitter->hDayBCD_bDayBCD=((UINT16)recv->h_day<<EPH_COMM_BYTE_BITS)|recv->b_day;
    //===== MSP430FR2476 結束FRAM操作必須關閉 write protect =====
    FK_ENABLE_FRAM_WRITE_PROTECT();

}
//**********************************************************************************************************************
//
// Copyright (C) 2010, FINE-TEK CO.,LTD. Taiwan  All Rights Reserved
//
//! @fn 			 eph_comm_read_register_cmd
//
//! @author 	 Jacky Lin
//
//! @date 		 2022/07/26
//
//! @brief 		 task function
//
//! @param 		 None
//
//! @return 	 None
//
//**********************************************************************************************************************
void eph_comm_read_register_cmd(UINT8 ptr)
{
    STC_EPH_COMM_READ_WRITE_REGISTER_CMD_PACKAGE cmd;
    UINT16 register_value=EPH_COMM_ADDRESS_REALTIME;
    cmd.device_id=gb_eph_comm_device_tlb[ptr];
    cmd.function_code=EPH_COMM_FUNC_READ_REGISTER;
    cmd.register_value_h=(UINT8)((register_value&EPH_COMM_HIGH_BYTE_MASK)>>EPH_COMM_BYTE_BITS);
    cmd.register_value_l=(UINT8)(register_value&EPH_COMM_LOW_BYTE_MASK);
    memset(cmd.set_parameter,0x00,sizeof(cmd.set_parameter)); //===== eph 訊號轉換器沒有timestamp, 所以都設定為"0"
    cmd.crc_check=EPH_COMM_CRC_CODE_API((UINT8*)&cmd,sizeof(cmd)-EPH_COMM_CRC_LEN);
    EPH_COMM_REGISTER_COMMAND(&cmd, sizeof(cmd));
}  
//**********************************************************************************************************************
//
// Copyright (C) 2010, FINE-TEK CO.,LTD. Taiwan  All Rights Reserved
//
//! @fn 			 eph_comm_wake_toggle
//
//! @author 	 Jacky Lin
//
//! @date 		 2022/08/02
//
//! @brief 		 task function
//
//! @param 		 None
//
//! @return 	 None
//
//**********************************************************************************************************************
void eph_comm_transmitter_process()
{
    //===== 與EPH通訊的process, wakeup(HI)->1ms->wakeup(LO)->1ms->send_command, Ver 0.0.02 =====
    switch(gb_eph_comm_transmitter_state)
    {
    case EPH_COMM_TRANSMITTER_STATE_WAKUP_HI:       
        EPH_COMM_WAKEUP_HIGH();
        EPH_COMM_TRANSMITTER_PROCESS_TIMEOUT(1);        
      break;
    case EPH_COMM_TRANSMITTER_STATE_WAKUP_LO:        
        EPH_COMM_WAKEUP_LOW(); 
        EPH_COMM_TRANSMITTER_PROCESS_TIMEOUT(1);
      break;
    case EPH_COMM_TRANSMITTER_STATE_SEND_CMD:
      //===== 競爭廠商RS485模式下, 讀取命令都只針對ID1的EPH水表, Ver 0.0.03 =====
        if(gb_eph_comm_rs485_state==EPH_COMM_RS485STA_FUNC_OK)
            eph_comm_read_register_cmd(0);
        else
            eph_comm_read_register_cmd(gb_eph_comm_device_ptr);
      break;
    }
    if(++gb_eph_comm_transmitter_state>=EPH_COMM_TRANSMITTER_STATE_TOTAL)
      gb_eph_comm_transmitter_state=EPH_COMM_TRANSMITTER_STATE_WAKUP_HI;
}
//**********************************************************************************************************************
//
// Copyright (C) 2010, FINE-TEK CO.,LTD. Taiwan  All Rights Reserved
//
//! @fn 			 eph_comm_timeout_isr
//
//! @author 	 Jacky Lin
//
//! @date 		 2022/08/09
//
//! @brief 		 task function
//
//! @param 		 None
//
//! @return 	 None
//
//**********************************************************************************************************************
void eph_comm_timeout_isr()
{
    if(gb_eph_comm_rs485_state==EPH_COMM_RS485STA_FUNC_OK)
      return;
    
    gb_eph_comm_rs485_state=EPH_COMM_RS485STA_IDEL;   
    gb_eph_comm_rs485_ptr=0;
}
//**********************************************************************************************************************
//
// Copyright (C) 2010, FINE-TEK CO.,LTD. Taiwan  All Rights Reserved
//
//! @fn 			 eph_comm_task
//
//! @author 	 Jacky Lin
//
//! @date 		 2022/07/26
//
//! @brief 		 task function
//
//! @param 		 None
//
//! @return 	 None
//
//**********************************************************************************************************************
void eph_comm_task()
{

}
#ifdef __cplusplus
}
#endif

